import os
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsMapLayer,QgsLayerTreeGroup,QgsLayerTreeLayer, QgsCoordinateReferenceSystem,
    QgsRectangle, QgsDataSourceUri, QgsVectorFileWriter, QgsFields, QgsWkbTypes,QgsVectorSimplifyMethod,
    QgsField, QgsVectorLayerCache,QgsLayerTreeUtils
)
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
import processing
import sqlite3
import os


def export_layers_to_geopackage(output_filename, selected_layers=None, replace_project=True):
    """
    Exportuje vektorov√© vrstvy do form√°tu GeoPackage (.gpkg) a nahrad√≠ projekt nov√Ωm,
    kter√Ω spr√°vnƒõ odkazuje na vrstvy v GeoPackage.
    
    Parametry:
        output_filename (str): N√°zev v√Ωstupn√≠ho souboru (bez p≈ô√≠pony)
        selected_layers (list): Seznam n√°zv≈Ø vrstev k exportu. Pokud je None, exportuj√≠ se v≈°echny viditeln√© vrstvy.
        replace_project (bool): Pokud True, nahrad√≠ projekt nov√Ωm se spr√°vnƒõ naƒçten√Ωmi vrstvami
    
    N√°vratov√° hodnota:
        bool: True pokud byl export √∫spƒõ≈°n√Ω, jinak False
    """
    # Odvodit v√Ωstupn√≠ adres√°≈ô z output_filename
    output_dir = os.path.dirname(output_filename)
    if not output_dir:
        output_dir = os.getcwd()
        output_filename = os.path.join(output_dir, output_filename)
    
    # Vytvo≈ôen√≠ output adres√°≈ôe, pokud neexistuje
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Z√≠sk√°n√≠ projektu
    project = QgsProject.instance()
    
    # Urƒçen√≠, kter√© vrstvy budou exportov√°ny
    layers_to_export = []
    if selected_layers:
        # Export jen specifikovan√Ωch vrstev
        for layer_name in selected_layers:
            layers = project.mapLayersByName(layer_name)
            if layers:
                layers_to_export.append(layers[0])
    else:
        # Export v≈°ech viditeln√Ωch vrstev
        root = project.layerTreeRoot()
        for layer in root.findLayers():
            if layer.isVisible():
                layers_to_export.append(layer.layer())
    
    if not layers_to_export:
        print("≈Ω√°dn√© vrstvy ke exportu!")
        return False
    
    print(f"Nalezeno {len(layers_to_export)} vrstev k exportu.")
    
    # Filtrujeme jen vektorov√© vrstvy
    output_gpkg = output_filename if output_filename.endswith('.gpkg') else output_filename + '.gpkg'

# Filtrujeme jen vektorov√© vrstvy
    vector_layers = [layer for layer in layers_to_export if layer.type() == QgsMapLayer.VectorLayer]

    # Vytvo≈ô√≠me slovn√≠k pro mapov√°n√≠ mezi origin√°ln√≠mi n√°zvy a ID
    original_names = {}

    # Nastav√≠me n√°zvy vrstev na jejich ID
    for vector_layer in vector_layers:
        original_name = vector_layer.name()
        layer_id = 'tab' + vector_layer.id()
        
        # Zapamatujeme si mapov√°n√≠ mezi ID a p≈Øvodn√≠m n√°zvem
        original_names[layer_id] = original_name
        
        # Nastav√≠me n√°zev vrstvy na ID
        vector_layer.setName(layer_id)
        
        print(f"Vrstva '{original_name}' bude exportov√°na s ID jako n√°zvem")

    # Nyn√≠ m≈Ø≈æeme exportovat vrstvy do GeoPackage
    parameters = {
        'LAYERS': vector_layers,
        'OUTPUT': output_gpkg,
        'OVERWRITE': True,
        'SAVE_STYLES': True,
        'SAVE_METADATA': True,
    }

    export_success = False
    try:
        # Pou≈æit√≠ n√°stroje "package layers" pro export do GeoPackage
        result = processing.run("native:package", parameters)
        print(f"Export vrstev dokonƒçen: {result}")
        export_success = True
        
        # Po exportu aktualizujeme popisy vrstev v GeoPackage
        
        try:
            conn = sqlite3.connect(output_gpkg)
            cursor = conn.cursor()
            
            # Pro ka≈æd√© ID vrstvy aktualizujeme popis v tabulce gpkg_contents
            for layer_id, original_name in original_names.items():
                # Aktualizujeme popis v tabulce gpkg_contents
                cursor.execute(
                    "UPDATE gpkg_contents SET description = ? WHERE table_name = ?",
                    (f"Original name: {original_name}", layer_id)
                )
            
            conn.commit()
            conn.close()
            print("Popis vrstev v GeoPackage byl aktualizov√°n.")
        except sqlite3.Error as sqlite_error:
            print(f"CHYBA p≈ôi aktualizaci popis≈Ø v GeoPackage: {str(sqlite_error)}")
        
    except Exception as e:
        print(f"Do≈°lo k chybƒõ bƒõhem exportu vrstev: {str(e)}")
        import traceback
        traceback.print_exc()
        export_success = False
    finally:
        # V≈ædy obnov√≠me p≈Øvodn√≠ n√°zvy vrstev
        for vector_layer in vector_layers:
            layer_id = vector_layer.id()
            if layer_id in original_names:
                vector_layer.setName(original_names[layer_id])    


# V ƒç√°sti kde exportujeme vrstvy do GeoPackage (ve funkci export_layers_to_geopackage)

# Po √∫spƒõ≈°n√©m exportu p≈ôid√°me prostorov√© indexy do GeoPackage
    if export_success:
        print("Vytv√°≈ô√≠m prostorov√© indexy pro zrychlen√≠...")
        try:
            conn = sqlite3.connect(output_gpkg)
            cursor = conn.cursor()
            
                    # AKTIVACE SPATIALITE ROZ≈†√ç≈òEN√ç
            print("Aktivuji SpatiaLite roz≈°√≠≈ôen√≠ pro ST_ funkce...")
            spatialite_loaded = False
            
            # Povolen√≠ naƒç√≠t√°n√≠ roz≈°√≠≈ôen√≠
            try:
                conn.enable_load_extension(True)
                
                # R≈Øzn√© cesty k SpatiaLite podle OS
                spatialite_paths = [
                    # QGIS cesty
                    "C:\\Program Files\\QGIS 3.32.3\\bin\\mod_spatialite.dll"
                ]
                
                for path in spatialite_paths:
                    try:
                        conn.load_extension(path)
                        print(f"‚úì SpatiaLite naƒçteno z: {path}")
                        spatialite_loaded = True
                        break
                    except sqlite3.Error:
                        continue
                        
                if not spatialite_loaded:
                    print("‚ö† Nepoda≈ôilo se naƒç√≠st SpatiaLite automaticky")
                    print("üí° Zkuste ruƒçnƒõ naj√≠t mod_spatialite.dll v instalaci QGIS")
                    
            except sqlite3.Error as e:
                print(f"‚ö† Nelze povolit naƒç√≠t√°n√≠ roz≈°√≠≈ôen√≠: {e}")
            
            # Test ST_ funkc√≠
            st_functions_available = False
            if spatialite_loaded:
                try:
                    cursor.execute("SELECT ST_GeomFromText('POINT(0 0)')")
                    st_functions_available = True
                    print("‚úì ST_ funkce jsou aktivn√≠!")
                except sqlite3.Error:
                    print("‚úó ST_ funkce st√°le nejsou dostupn√©")
        
            
            
            
            
            
            # Provedeme optimalizace SQLite pro lep≈°√≠ v√Ωkon
            cursor.execute("PRAGMA journal_mode = WAL")  # Write-Ahead Logging pro lep≈°√≠ soubƒõ≈æn√Ω p≈ô√≠stup
            cursor.execute("PRAGMA synchronous = NORMAL")  # M√©nƒõ ƒçast√° synchronizace s diskem
            cursor.execute("PRAGMA cache_size = 100000")  # Vƒõt≈°√≠ cache (p≈ôibli≈ænƒõ 10 MB)
            cursor.execute("PRAGMA temp_store = MEMORY")  # Doƒçasn√© tabulky v pamƒõti
            cursor.execute("PRAGMA locking_mode = EXCLUSIVE")  # Exkluzivn√≠ z√°mek bƒõhem operac√≠
                    # Z√≠sk√°n√≠ seznamu v≈°ech geometrick√Ωch tabulek
            cursor.execute("SELECT table_name, column_name FROM gpkg_geometry_columns")
            geometry_tables = cursor.fetchall()
            
            if not geometry_tables:
                print("≈Ω√°dn√© geometrick√© tabulky nenalezeny.")
                conn.close()
                return
            
            print(f"Nalezeno {len(geometry_tables)} geometrick√Ωch tabulek.")
          # 1. VYTVO≈òEN√ç PROSTOROV√ùCH INDEX≈Æ (RTree)
            print("Vytv√°≈ô√≠m klasick√© indexy na atributy...")
            
            for table_name, column_name in geometry_tables:
                try:
                    # Index na FID (prim√°rn√≠ kl√≠ƒç)
                    fid_index_sql = f'CREATE INDEX IF NOT EXISTS idx_{table_name}_fid ON "{table_name}"(fid)'
                    cursor.execute(fid_index_sql)
                    print(f"‚úì Index na FID pro {table_name} vytvo≈ôen")
                    
                    # Z√≠sk√°n√≠ seznamu v≈°ech sloupc≈Ø tabulky (kromƒõ geometrick√©ho)
                    cursor.execute(f'PRAGMA table_info("{table_name}")')
                    columns = cursor.fetchall()
                    
                    for col_info in columns:
                        col_name = col_info[1]  # n√°zev sloupce
                        col_type = col_info[2]  # typ sloupce
                        
                        # P≈ôeskoƒç√≠me geometrick√Ω sloupec, fid a BLOB sloupce
                        if (col_name.lower() in [column_name.lower(), 'fid', 'geom', 'geometry', 'shape'] or 
                            col_type.upper() in ['GEOMETRY', 'BLOB']):
                            continue
                        
                        try:
                            # Vytvo≈ôen√≠ indexu na atributov√Ω sloupec
                            attr_index_sql = f'CREATE INDEX IF NOT EXISTS idx_{table_name}_{col_name} ON "{table_name}"({col_name})'
                            cursor.execute(attr_index_sql)
                            print(f"‚úì Index na {table_name}.{col_name} vytvo≈ôen")
                        except sqlite3.Error as e:
                            print(f"‚úó Nelze vytvo≈ôit index na {table_name}.{col_name}: {e}")
                            
                except sqlite3.Error as e:
                    print(f"‚úó Chyba p≈ôi vytv√°≈ôen√≠ atributov√Ωch index≈Ø pro {table_name}: {e}")
                                
            # 2. VYTVO≈òEN√ç KLASICK√ùCH INDEX≈Æ NA ATRIBUTY
           
            
             # 3. VOLITELN√â ST_ FUNKƒåN√ç INDEXY (pokud jsou dostupn√©)
            """
            print("Zkou≈°√≠m vytvo≈ôit ST_ funkƒçn√≠ indexy...")
            
            for table_name, column_name in geometry_tables:
                try:
                   
                   
                    
                    # Test, zda ST_ funkce funguj√≠
                    test_sql = f'SELECT ST_MinX({column_name}) FROM "{table_name}" LIMIT 1'
                    cursor.execute(test_sql)
                    
                    # Pokud test pro≈°el, vytvo≈ô√≠me ST_ indexy
                    st_indexes = [
                        (f'idx_{table_name}_minx', f'ST_MinX("{table_name}")'),
                        (f'idx_{table_name}_maxx', f'ST_MaxX("{table_name}")'),
                        (f'idx_{table_name}_miny', f'ST_MinY("{table_name}")'),
                        (f'idx_{table_name}_maxy', f'ST_MaxY("{table_name}")')
                    ]
                    
                    for index_name, function_call in st_indexes:
                        try:
                            st_index_sql = f'CREATE INDEX IF NOT EXISTS {index_name} ON "{table_name}"({function_call})'
                            cursor.execute(st_index_sql)
                            print(f"‚úì ST_ index {index_name} vytvo≈ôen")
                        except sqlite3.Error as e:
                            print(f"‚úó ST_ index {index_name} selhal: {e}")
                            break  # Pokud jeden sel≈æe, ostatn√≠ tak√© nebudou fungovat
                            
                except sqlite3.Error:
                    print(f"‚ö† ST_ funkce nejsou dostupn√© pro {table_name}, p≈ôeskakuji ST_ indexy")
                    break  # P≈ôeru≈°√≠me smyƒçku, ST_ funkce nefunguj√≠
            
            
            """
            
            
            
            # 3. OPTIMALIZACE DATAB√ÅZE
            print("Optimalizuji datab√°zi...")
            try:
                cursor.execute("ANALYZE")
                print("‚úì ANALYZE dokonƒçen")
                cursor.execute("VACUUM")
                print("‚úì VACUUM dokonƒçen")
            except sqlite3.Error as e:
                print(f"‚úó Chyba p≈ôi optimalizaci: {e}")
            
            conn.commit()
            conn.close()
        

            conn.commit()
            conn.close()
            print("Prostorov√© indexy byly vytvo≈ôeny nebo aktualizov√°ny.")
            # 2. VYTVO≈òEN√ç KLASICK√ùCH INDEX≈Æ NA ATRIBUTY
            print("Vytv√°≈ô√≠m klasick√© indexy na atributy...")
            
            for table_name, column_name in geometry_tables:
                try:
                    # Index na FID (prim√°rn√≠ kl√≠ƒç)
                    fid_index_sql = f"CREATE INDEX IF NOT EXISTS idx_{table_name}_fid ON {table_name}(fid)"
                    cursor.execute(fid_index_sql)
                    print(f"‚úì Index na FID pro {table_name} vytvo≈ôen")
                    
                    # Z√≠sk√°n√≠ seznamu v≈°ech sloupc≈Ø tabulky (kromƒõ geometrick√©ho)
                    cursor.execute(f'PRAGMA table_info("{table_name}")')
                    columns = cursor.fetchall()
                    
                    for col_info in columns:
                        col_name = col_info[1]  # n√°zev sloupce
                        col_type = col_info[2]  # typ sloupce
                        
                        # P≈ôeskoƒç√≠me geometrick√Ω sloupec, fid a BLOB sloupce
                        if (col_name.lower() in [column_name.lower(), 'fid', 'geom', 'geometry', 'shape'] or 
                            col_type.upper() in ['GEOMETRY', 'BLOB']):
                            continue
                        
                        try:
                            # Vytvo≈ôen√≠ indexu na atributov√Ω sloupec
                            attr_index_sql = f'CREATE INDEX IF NOT EXISTS idx_{table_name}_{col_name} ON "{table_name}"({col_name})'
                            cursor.execute(attr_index_sql)
                            print(f"‚úì Index na {table_name}.{col_name} vytvo≈ôen")
                        except sqlite3.Error as e:
                            print(f"‚úó Nelze vytvo≈ôit index na {table_name}.{col_name}: {e}")
                            
                except sqlite3.Error as e:
                    print(f"‚úó Chyba p≈ôi vytv√°≈ôen√≠ atributov√Ωch index≈Ø pro {table_name}: {e}")
        except sqlite3.Error as sqlite_error:
            print(f"CHYBA p≈ôi vytv√°≈ôen√≠ prostorov√Ωch index≈Ø: {str(sqlite_error)}")
                
    # Ovƒõ≈ôen√≠, zda soubor existuje
    if os.path.exists(output_gpkg):
        file_size = os.path.getsize(output_gpkg)
        print(f"Soubor √∫spƒõ≈°nƒõ vytvo≈ôen: {output_gpkg}")
        print(f"Velikost souboru: {file_size / 1024:.2f} KB")
        
        
        
        # Nahrazen√≠ projektu QGIS nov√Ωm se spr√°vnƒõ naƒçten√Ωmi vrstvami
        if replace_project and export_success:
            replaced = create_new_project_from_gpkg(output_gpkg)
            if replaced:
                print(f"Vytvo≈ôen nov√Ω projekt s vrstvami z GeoPackage.")
            else:
                print(f"Nepoda≈ôilo se vytvo≈ôit nov√Ω projekt.")
        
        return True
    else:
        print(f"Soubor nebyl vytvo≈ôen!")
        return False
    
def create_new_project_from_gpkg(gpkg_path, save_to_gpkg=True, use_caching=True):
    """
    Vytvo≈ô√≠ nov√Ω projekt s hierarchi√≠ skupin z aktu√°ln√≠ho projektu a vrstvami z GeoPackage,
    bez ukl√°d√°n√≠ projektu do GeoPackage. Nastav√≠ pracovn√≠ adres√°≈ô projektu na adres√°≈ô s GeoPackage.
    
    Parametry:
        gpkg_path (str): Cesta k GeoPackage souboru
    
    N√°vratov√° hodnota:
        bool: True pokud byl projekt √∫spƒõ≈°nƒõ vytvo≈ôen, jinak False
    """
    
    global layer_caches
    layer_caches = {}
    
    try:

        # Z√≠sk√°me n√°zev souboru a adres√°≈ô z cesty
        gpkg_filename = os.path.basename(gpkg_path)
        gpkg_dir = os.path.dirname(gpkg_path)
        
        if not gpkg_dir:  # Pokud je cesta relativn√≠ a nem√° adres√°≈ô
            gpkg_dir = os.getcwd()
        
        print(f"Pracuji s GeoPackage souborem: {gpkg_filename}")
        print(f"Adres√°≈ô GeoPackage: {gpkg_dir}")
        
        # Z√≠sk√°me referenci na aktu√°ln√≠ projekt
        current_project = QgsProject.instance()
        current_root = current_project.layerTreeRoot()
        
        # Nejprve si ulo≈æ√≠me informace o hierarchii skupin a vrstv√°ch
        group_structure = []
        
        # Funkce pro rekurzivn√≠ proch√°zen√≠ hierarchie a ukl√°d√°n√≠ informac√≠
        def save_hierarchy(group, parent_path=""):
            group_info = {
                "name": group.name(),
                "path": f"{parent_path}/{group.name()}" if parent_path else group.name(),
                "groups": [],
                "layers": []
            }
            
            # Proch√°z√≠me dƒõti skupiny
            for child in group.children():
                if isinstance(child, QgsLayerTreeGroup):
                    # Rekurzivnƒõ zpracujeme podskupinu
                    child_info = save_hierarchy(child, group_info["path"])
                    group_info["groups"].append(child_info)
                elif isinstance(child, QgsLayerTreeLayer):
                    # Ulo≈æ√≠me informace o vrstvƒõ
                    layer = child.layer()
                    if layer and layer.type() == QgsMapLayer.VectorLayer:
                        layer_info = {
                            "name": layer.name(),
                            "id": layer.id(),  # Ulo≈æ√≠me ID vrstvy
                            "visible": child.itemVisibilityChecked()
                        }
                        group_info["layers"].append(layer_info)
            
            return group_info
        
        # Ulo≈æ√≠me hierarchii skupin
        hierarchy = save_hierarchy(current_root)
        
        print(f"Ulo≈æena hierarchie skupin a vrstev z p≈Øvodn√≠ho projektu.")
        
        # Nyn√≠ vyƒçist√≠me aktu√°ln√≠ projekt
        current_project.clear()
        new_root = current_project.layerTreeRoot()
        
        # Nastav√≠me pracovn√≠ adres√°≈ô projektu
        current_project.setPresetHomePath(gpkg_dir)
        # Nastavit pou≈æit√≠ relativn√≠ch cest pro cel√Ω projekt
        current_project.writeEntry("Paths", "Absolute", False)

        # Tak√© je dobr√© nastavit z√°kladn√≠ cestu pro relativn√≠ cesty (obvykle adres√°≈ô projektu)
        current_project.writeEntry("Paths", "Path", ".")

        # Aktualizovat nastaven√≠
        current_project.write()
        # Po vytvo≈ôen√≠ nov√©ho projektu a p≈ôed naƒçten√≠m vrstev z GeoPackage:
        # Nastaven√≠ sou≈ôadnicov√©ho syst√©mu na EPSG:5514 (S-JTSK / Krovak East North)
        try:
            # Vytvo≈ô√≠me instanci sou≈ôadnicov√©ho syst√©mu EPSG:5514
            crs = QgsCoordinateReferenceSystem("EPSG:5514")
            
            if crs.isValid():
                # Nastav√≠me sou≈ôadnicov√Ω syst√©m projektu
                current_project.setCrs(crs)
                print(f"Sou≈ôadnicov√Ω syst√©m projektu nastaven na: {crs.description()} ({crs.authid()})")
            else:
                print("VAROV√ÅN√ç: Nelze vytvo≈ôit platn√Ω sou≈ôadnicov√Ω syst√©m EPSG:5514!")
        except Exception as e:
            print(f"Chyba p≈ôi nastavov√°n√≠ sou≈ôadnicov√©ho syst√©mu: {str(e)}")
        
        
        
        
        
        print(f"Vytvo≈ôen nov√Ω projekt. Pracovn√≠ adres√°≈ô nastaven na: {gpkg_dir}")
        print(f"P≈ôipojuji vrstvy z {gpkg_filename}")
        
        # Naƒçteme informace o p≈Øvodn√≠ch n√°zvech vrstev z GeoPackage
        
        try:
            conn = sqlite3.connect(gpkg_path)
            cursor = conn.cursor()
            
            # Z√≠sk√°me seznam vrstev s jejich popisy
            cursor.execute("SELECT table_name, description FROM gpkg_contents WHERE data_type='features'")
            layers_info = {row[0]: row[1] for row in cursor.fetchall()}
            conn.close()
        except sqlite3.Error as sqlite_error:
            print(f"CHYBA p≈ôi ƒçten√≠ z GeoPackage: {str(sqlite_error)}")
            layers_info = {}
        
        # Slovn√≠ky pro mapov√°n√≠ vrstev
        id_to_layer = {}     # Mapov√°n√≠ ID -> vrstva
        name_to_layer = {}   # Mapov√°n√≠ n√°zev -> vrstva
        
        # Nejprve naƒçteme v≈°echny vrstvy z GeoPackage
        for table_name, description in layers_info.items():
            # P≈ôeskoƒç√≠me syst√©mov√© tabulky
            if table_name.startswith('gpkg_') or table_name.startswith('sqlite_') or table_name.startswith('rtree_') or table_name == 'empty':
                continue
            print("table name " + table_name)        
            # Naƒçteme vrstvu z GeoPackage
            gpgk_basename = os.path.basename(gpkg_path)
            layer_path = f"{gpkg_path}|layername={table_name}"

           # P≈ôi naƒç√≠t√°n√≠ vrstvy z GeoPackage (ve funkci create_new_project_from_gpkg)

            # M√≠sto k√≥du:
            new_layer = QgsVectorLayer(layer_path, table_name, "ogr")

            # Pou≈æijeme toto s dodateƒçn√Ωmi parametry:
            """
            uri = QgsDataSourceUri()
            uri.setDatabase(gpkg_path)
            uri.setDataSource('', table_name, 'geom', '', 'ogc_fid')
            new_layer = QgsVectorLayer(uri.uri(), table_name, "ogr")
            """
            # Nastaven√≠ vykreslov√°n√≠ po naƒçten√≠
            if new_layer.isValid():
                
                # Nastaven√≠ optim√°ln√≠ velikosti vyrovn√°vac√≠ pamƒõti
                new_layer.setReadExtentFromXml(True)  # Naƒç√≠t√° jen rozsah z XML
                
                # Nastaven√≠ chov√°n√≠ pamƒõti cache
                ##new_layer.setFeatureCacheEstablished(True)
                
                # Optimalizace renderer≈Ø pro velk√© vrstvy
                renderer = new_layer.renderer()
                if renderer:
                    renderer.setForceRasterRender(False)  # Pro vektorov√© vykreslov√°n√≠ pou≈æijeme False 
                        
            
            
            
            
            
            if new_layer.isValid():
                
                # Zkontrolujeme, zda m√° vrstva platn√© filtry
                if new_layer.subsetString():
                    print(f"Vrstva {table_name} m√° filtr: {new_layer.subsetString()}")
                    # Pokud je filtr pr√°zdn√Ω nebo zp≈Øsobuje chyby, zkus√≠me ho vyƒçistit
                    if new_layer.subsetString().strip() == "":
                        new_layer.setSubsetString("")
                        print(f"Vyƒçi≈°tƒõn pr√°zdn√Ω filtr pro vrstvu {table_name}")
                
                
                
                # Z√≠sk√°me p≈Øvodn√≠ n√°zev z popisu, pokud existuje
                original_name = table_name  # V√Ωchoz√≠ je pou≈æ√≠t n√°zev tabulky
                if description and description.startswith("Original name: "):
                    original_name = description[len("Original name: "):]
                
                # Nastav√≠me p≈Øvodn√≠ n√°zev vrstvy
                new_layer.setName(original_name)
                
                # Ulo≈æ√≠me vrstvu do slovn√≠k≈Ø pro vyhled√°v√°n√≠
                id_to_layer[table_name] = new_layer
                name_to_layer[original_name] = new_layer
                print(f"Naƒçtena vrstva: {original_name} z tabulky {table_name}")
            else:
                print(f"CHYBA: Nelze naƒç√≠st vrstvu {table_name}")
        
        # Funkce pro vytvo≈ôen√≠ struktury skupin podle ulo≈æen√© hierarchie
        def recreate_hierarchy(group_info, parent_group):
            # Vytvo≈ô√≠me skupinu
            if group_info["name"] != parent_group.name():  # P≈ôeskoƒç√≠me ko≈ôenovou skupinu
                new_group = parent_group.addGroup(group_info["name"])
                print(f"Vytvo≈ôena skupina: {group_info['path']}")
            else:
                new_group = parent_group
            
            # P≈ôid√°me vrstvy do skupiny
            for layer_info in group_info["layers"]:
                layer_name = layer_info["name"]
                layer_id = layer_info["id"]
                
                # Nejprve zkus√≠me naj√≠t vrstvu podle ID
                if layer_id in id_to_layer:
                    new_layer = id_to_layer[layer_id]
                    current_project.addMapLayer(new_layer, False)  # False znamen√°, ≈æe se vrstva nep≈ôid√° do root
                    new_group.addLayer(new_layer)
                    print(f"P≈ôid√°na vrstva {layer_name} (podle ID: {layer_id}) do skupiny {group_info['path']}")
                    
                    # Nastav√≠me viditelnost
                    new_layer_node = new_group.findLayer(new_layer.id())
                    if new_layer_node:
                        new_layer_node.setItemVisibilityChecked(layer_info["visible"])
                    
                    # Oznaƒç√≠me jako pou≈æitou
                    id_to_layer.pop(layer_id, None)
                    if new_layer.name() in name_to_layer:
                        name_to_layer.pop(new_layer.name(), None)

                else:
                    print(f"Vrstva '{layer_name}' (ID: {layer_id}) nenalezena v GeoPackage, p≈ôeskakuji...")
            
            # Rekurzivnƒõ vytvo≈ô√≠me podskupiny
            for subgroup_info in group_info["groups"]:
                recreate_hierarchy(subgroup_info, new_group)
        
        # Vytvo≈ô√≠me strukturu skupin a p≈ôid√°me vrstvy
        recreate_hierarchy(hierarchy, new_root)

        
        # Slouƒç√≠me zb√Ωvaj√≠c√≠ slovn√≠ky, abychom mƒõli p≈ôehled o v≈°ech zb√Ωvaj√≠c√≠ch vrstv√°ch
        remaining_layers = {}
        remaining_layers.update(id_to_layer)
        remaining_layers.update(name_to_layer)
        
        # P≈ôid√°me v≈°echny zb√Ωvaj√≠c√≠ vrstvy, kter√© nebyly p≈ôid√°ny do hierarchie
        if remaining_layers:
            print(f"P≈ôid√°v√°m zb√Ωvaj√≠c√≠ vrstvy do ko≈ôenov√© √∫rovnƒõ...")
            for key, layer in remaining_layers.items():
                # Kontrola, zda vrstva ji≈æ nen√≠ v projektu
                if not current_project.mapLayer(layer.id()):
                    current_project.addMapLayer(layer)
                    print(f"P≈ôid√°na vrstva {layer.name()} do ko≈ôenov√© √∫rovnƒõ (nebyla v p≈Øvodn√≠ hierarchii)")
        
        # Nastav√≠me n√°zev projektu na n√°zev GeoPackage souboru (bez p≈ô√≠pony)
        project_name = os.path.splitext(gpkg_filename)[0]
        current_project.setTitle(project_name)
        
        print(f"Projekt '{project_name}' byl √∫spƒõ≈°nƒõ vytvo≈ôen s vrstvami z {gpkg_filename}")
        print(f"Pracovn√≠ adres√°≈ô projektu nastaven na: {gpkg_dir}")
                

        if use_caching:
            print("Optimalizuji projekt pomoc√≠ QgsVectorLayerCache...")
            layer_caches = optimize_project_with_caching(current_project)
  

                
        # Po naƒçten√≠ vrstev z GeoPackage a p≈ôed ulo≈æen√≠m projektu:

        # Optimalizace vykreslov√°n√≠ pro lep≈°√≠ v√Ωkon
        print("Optimalizuji nastaven√≠ projektu pro rychlej≈°√≠ vykreslov√°n√≠...")

        # Z√≠sk√°me p≈ô√≠stup k mapov√©mu pl√°tnu
        canvas = iface.mapCanvas()

        # Nastaven√≠ vykreslov√°n√≠ pro lep≈°√≠ v√Ωkon
        if canvas:
            # Nastaven√≠ simplifikace geometri√≠
            canvas.setMapUpdateInterval(100)  # Intervalov√© vykreslov√°n√≠ (ms)
            
            # Nastaven√≠ pro v≈°echny vektorov√© vrstvy
            for layer_id, layer in id_to_layer.items():
                if layer.type() == QgsMapLayer.VectorLayer:
                    # Nastaven√≠ simplifikace geometri√≠
                    layer.setSimplifyMethod(QgsVectorSimplifyMethod())
                    layer.simplifyMethod().setSimplifyHints(QgsVectorSimplifyMethod.SimplifyHints(
                        QgsVectorSimplifyMethod.SimplifyHint.GeometrySimplification |
                        QgsVectorSimplifyMethod.SimplifyHint.AntialiasingOptimization
                    ))
                    layer.simplifyMethod().setThreshold(1.0)  # Hodnota prahu simplifikace
                    
                    # Zapnut√≠ mezipamƒõti vykreslov√°n√≠
                    layer.setUsingRendererV2CacheFlag(True)
                    
                    # Nastaven√≠ maxim√°ln√≠ho mƒõ≈ô√≠tka viditelnosti pro rozs√°hl√© vrstvy (pokud vrstva obsahuje mnoho prvk≈Ø)
                    if layer.featureCount() > 10000:  # Pro vrstvy s v√≠ce ne≈æ 10 000 prvky
                        layer.setMaximumScale(1000000)  # Zobraz√≠ se a≈æ p≈ôi p≈ôibl√≠≈æen√≠
                        print(f"Nastaveno maxim√°ln√≠ mƒõ≈ô√≠tko viditelnosti pro vrstvu {layer.name()} (mnoho prvk≈Ø)")
            
            print("Nastaven√≠ projektu optimalizov√°no pro rychlej≈°√≠ vykreslov√°n√≠.")                
                
                
                
                
        QgsLayerTreeUtils.updateEmbeddedGroupsProjectPath(new_root,current_project )
        current_project.write()
         
                
        if save_to_gpkg:
            try:
                # Ulo≈æen√≠ projektu do GeoPackage
                project_path = f"geopackage:{gpkg_path}?projectName={project_name}"
                save_success = current_project.write(project_path)
                
                if save_success:
                    print(f"Projekt byl √∫spƒõ≈°nƒõ ulo≈æen do GeoPackage: {gpkg_path}")
                    print(f"N√°zev projektu v GeoPackage: {project_name}")
                else:
                    print(f"CHYBA: Nepoda≈ôilo se ulo≈æit projekt do GeoPackage!")
            except Exception as e:
                print(f"Chyba p≈ôi ukl√°d√°n√≠ projektu do GeoPackage: {str(e)}")
                import traceback
                traceback.print_exc()
                return False
        
        return True            
    except Exception as e:
        print(f"Chyba p≈ôi vytv√°≈ôen√≠ nov√©ho projektu: {str(e)}")
        import traceback
        traceback.print_exc()
        return False
    
def apply_vector_layer_cache(layer, cache_size=10000):
    """
    Aplikuje QgsVectorLayerCache na vrstvu pro rychlej≈°√≠ p≈ô√≠stup k dat≈Øm.
    
    Parametry:
        layer: QgsVectorLayer instance
        cache_size: velikost cache (poƒçet prvk≈Ø)
    
    N√°vratov√° hodnota:
        QgsVectorLayerCache instance nebo None p≈ôi chybƒõ
    """
    try:
        if layer and layer.isValid():
            # Vytvo≈ôen√≠ cache pro vrstvu
            layer_cache = QgsVectorLayerCache(layer, cache_size)
            
            # Nastaven√≠ cache pro v≈°echny prvky
            layer_cache.setCacheSize(cache_size)
            
            print(f"‚úì Cache {cache_size} prvk≈Ø aplikov√°na na vrstvu {layer.name()}")
            return layer_cache
        else:
            print(f"‚úó Nelze aplikovat cache - neplatn√° vrstva")
            return None
            
    except Exception as e:
        print(f"‚úó Chyba p≈ôi aplikaci cache na vrstvu {layer.name()}: {e}")
        return None


def optimize_project_with_caching(project, default_cache_size=10000):
    """
    Optimalizuje projekt pomoc√≠ QgsVectorLayerCache pro v≈°echny vektorov√© vrstvy.
    
    Parametry:
        project: QgsProject instance
        default_cache_size: v√Ωchoz√≠ velikost cache
    
    N√°vratov√° hodnota:
        dict: slovn√≠k s layer_id -> QgsVectorLayerCache
    """
    layer_caches = {}
    
    try:
        # Z√≠sk√°n√≠ v≈°ech vrstev v projektu
        layers = project.mapLayers()
        vector_layers = [layer for layer in layers.values() 
                        if layer.type() == QgsMapLayer.VectorLayer]
        
        print(f"Optimalizuji {len(vector_layers)} vektorov√Ωch vrstev pomoc√≠ cache...")
        
        for layer in vector_layers:
            try:
                # Urƒçen√≠ velikosti cache podle poƒçtu prvk≈Ø ve vrstvƒõ
                feature_count = layer.featureCount()
                
                if feature_count > 0:
                    # Adaptivn√≠ velikost cache podle poƒçtu prvk≈Ø
                    if feature_count < 1000:
                        cache_size = min(feature_count, 1000)
                    elif feature_count < 10000:
                        cache_size = min(feature_count, 5000)
                    else:
                        cache_size = default_cache_size
                    
                    # Aplikace cache na vrstvu
                    layer_cache = apply_vector_layer_cache(layer, cache_size)
                    
                    if layer_cache:
                        layer_caches[layer.id()] = layer_cache
                        print(f"‚úì Vrstva '{layer.name()}' optimalizov√°na (cache: {cache_size})")
                    else:
                        print(f"‚úó Nelze optimalizovat vrstvu {layer.name()}")
                else:
                    print(f"‚ö† Vrstva '{layer.name()}' je pr√°zdn√°, p≈ôeskakuji optimalizaci")
                    
            except Exception as e:
                print(f"‚úó Nelze optimalizovat vrstvu {layer.name()}: {e}")
        
        print(f"Cache optimalizace dokonƒçena pro {len(layer_caches)} vrstev")
        return layer_caches
        
    except Exception as e:
        print(f"Chyba p≈ôi optimalizaci projektu: {e}")
        return {}


def create_optimized_layer_path(gpkg_path, table_name):
    """
    Vytvo≈ô√≠ optimalizovanou cestu k vrstvƒõ v GeoPackage s parametry pro rychlej≈°√≠ naƒç√≠t√°n√≠.
    
    Parametry:
        gpkg_path: cesta k GeoPackage souboru
        table_name: n√°zev tabulky/vrstvy
        
    N√°vratov√° hodnota:
        str: optimalizovan√° cesta k vrstvƒõ
    """
    layer_path = f"{gpkg_path}|layername={table_name}"
    
    # P≈ôid√°n√≠ parametr≈Ø pro optimalizaci
    optimization_params = [
        "spatialindex=yes",      # Pou≈æit√≠ prostorov√©ho indexu
        "loadOnDemand=yes",      # Naƒç√≠t√°n√≠ na vy≈æ√°d√°n√≠
        "cacheFeatures=yes"      # Cache prvk≈Ø
    ]
    
    for param in optimization_params:
        layer_path += f"|{param}"
    
    return layer_path
